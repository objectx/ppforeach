import 'dart:io';
import 'dart:math';
import 'dart:typed_data';
import 'dart:convert';

import 'package:pointycastle/digests/blake2b.dart';
import 'package:typed_data/typed_data.dart';
import 'package:quiver/iterables.dart' as qvi;

class _ForEachGenerator {
  final int _maxArguments;
  final String _guard;

  _ForEachGenerator({int maxArguments = 64})
      : _maxArguments = maxArguments,
        _guard = _makeGuard(maxArguments);

  /// Maximum # of arguments to create.
  int get maxArguments => _maxArguments;

  /// The `preamble` section.
  String get preamble {
    return '''\
/* AUTOGENERATED -- DON'T EDIT! */
#pragma once
#ifndef ppforeach_${_guard}
#define ppforeach_${_guard}\t1

// Requires NEW C-Preprocessor
#if _MSVC_TRADITIONAL
#   error "You must use the NEW C-Preprocessor to compile. see https://blogs.msdn.microsoft.com/vcblog/2018/07/06/msvc-preprocessor-progress-towards-conformance/"
#endif''';
  }

  /// The `postamble` section.
  String get postamble {
    return '#endif\t/* ppforeach_${_guard} */';
  }

  /// The `ppforeach` API macros.
  String get toplevel {
    return '''\
#define PP_FOREACH(MACRO_, ...)\t\\
    PP_CAT (PP_FOREACH_${_guard}_, PP_ARG_COUNT_${_guard} (__VA_ARGS__)) (MACRO_, __VA_ARGS__)
#define PP_MAP(MACRO_, ...)\t\\
    PP_CAT (PP_MAP_${_guard}_, PP_ARG_COUNT_${_guard} (__VA_ARGS__)) (MACRO_, __VA_ARGS__)''';
  }

  /// The symbol concatenater.
  String get cat {
    return '''\
#ifndef PP_CAT
#define PP_CAT(A_, B_)\tPP_CAT_${_guard}_(A_, B_)
#define PP_CAT_${_guard}_(A_, B_)\tA_ ## B_
#endif''';
  }

  /// # of argument counting macros.
  String get counter {
    final cnt =
        qvi.range(_maxArguments, -1, -1).map((x) => x.toString()).join(", ");
    final args = qvi.range(0, _maxArguments).map((x) => 'x${x}_').join(", ");
    return '''\
#define PP_ARG_COUNT_${_guard}(...)\t\\
    PP_ARG_COUNT_${_guard}_ (__VA_ARGS__, ${cnt})
#define PP_ARG_COUNT_${_guard}_(${args}, COUNT_, ...)\t\\
    COUNT_''';
  }

  String _expander(int n) {
    if (n == 0) {
      return '''\
#define PP_FOREACH_${_guard}_0(M_)\t/* NO-OP */
#define PP_MAP_${_guard}_0(M_)\t/* NO-OP */''';
    }
    final args = qvi.range(0, n).map((x) => 'x${x}_').join(', ');
    return '''\
#define PP_FOREACH_${_guard}_${n}(M_, ${args})\t\\
    ${qvi.range(0, n).map((x) => 'M_ x${x}_').join(' ')}
#define PP_MAP_${_guard}_${n}(M_, ${args})\t\\
    ${qvi.range(0, n).map((x) => 'M_ (x${x}_)').join(', ')}''';
  }

  /// The engine of `PP_FOREACH` and `PP_MAP` macro.
  Iterable<String> get expander sync* {
    for (var i in qvi.range(0, _maxArguments + 1)) {
      yield _expander(i);
    }
  }
}

/// Generates the `ppforeach` code.
/// At most [argCount] arguments are handled in generated codes.
/// Results are written to [output].
void generate(IOSink output, int argCount) {
  final gen = _ForEachGenerator(maxArguments: argCount);
  output
    ..writeln(gen.preamble)
    ..writeln()
    ..writeln(gen.cat)
    ..writeln()
    ..writeln(gen.toplevel)
    ..writeln()
    ..writeln(gen.counter)
    ..writeln()
    ..writeln(gen.expander.join('\n'))
    ..writeln(gen.postamble);
}

String _makeGuard(int maxArguments) {
  final enc = AsciiEncoder();
  final h = Blake2bDigest(
      key: enc.convert('ppforeach'),
      salt: _makeBlake2Salt(enc.convert('objectx')));
  final mx = enc.convert('max_args=${maxArguments}');
  for (var v in mx) {
    h.updateByte(v);
  }
  final out = Uint8List(h.digestSize);
  h.doFinal(out, 0);
  //final out = h.process(mx);
  return _dumpHex(out).substring(0, min(16, 2 * out.length));
}

Uint8List _makeBlake2Salt(Uint8List s) {
  final b = Uint8Buffer(16);
  b
    ..fillRange(0, 16, 0)
    ..setRange(0, s.length, s);
  return b.buffer.asUint8List();
}

String _dumpHex(Uint8List v) {
  return v.map((x) => x.toRadixString(16).padLeft(2, '0')).join('');
}
